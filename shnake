#!/usr/bin/env bash

# game state

# set to whatever the last input direction was
# LEFT, RIGHT, UP, DOWN
declare -g NEXT_DIRECTION='RIGHT'

# should quit on q press
declare -g QUIT='false'

# SNAKE is an array with its head at index 0
# each entry consists of LINE:COLUMN
declare -ga SNAKE=( 0:2 0:1 0:0 )
# init should stay ion sync with NEXT_DIRECTION
declare -g SNAKE_DIRECTION="${NEXT_DIRECTION}"

# apple consisting of line:column:ttl
declare -g APPLE

# score count +1 for each apple
declare -g SCORE=0

# enable fancy mode
declare -g FANCY='false'

# enable logging and write to file specified here
declare -g LOG

# Z buffer for each cell
# keys are line:column and value is a single (printing) char
# calls to draw_scene will draw it to the screen
declare -gA ZBUF

# Stable LINES/COLUMNS
# if we get a size change mid-draw that's bad
# these stable versions pick up LINES/COLUMNS after draw_scene completes
declare -g SLINES
declare -g SCOLUMNS

# game logic

# log to file specified in LOG
# we can't log to STDERR because that messes with the screen
# and we can't redirect STDERR because checkwinsize requires 
# STDERR to be a terminal
function log() {
    [[ -z "${LOG}" ]] && return

    local fmt="${FUNCNAME[1]}: ${1}\n"
    shift

    # shellcheck disable=SC2059 # this is the wanted behaviour
    printf "${fmt}" "${@}" 1>>"${LOG}"
}

# log stacktrace and exit with message
function die() {
    local msg="${1}"
    log "Fatal error occured in %s: %s" \
        "${FUNCNAME[1]}" "${msg}"

    log "Stacktrace:"
    local i
    for (( i = ${#FUNCNAME[@]} - 1; i >= 0; i-- )); do
        log "called %s() in %s line %d" \
            "${FUNCNAME[${i}]}" \
            "${BASH_SOURCE[${i}]}" \
            "${BASH_LINENO[${i}]}"
    done
    exit 1
}

function help() {
    printf "Usage: %s\n" "${BASH_SOURCE[0]}"
    printf "  -h|--help      Print help\n"
    printf "  -f|--fancy     Enable fancy mode (colors and animations)\n"
    printf "  -l|--log FILE  Enable logging to FILE\n"
    printf "\n"
    printf "CONTROLS\n"
    printf "  arrow keys     Change direction\n"
    printf "           q     Quit\n"
}

function parse_args() {
    while (( ${#} > 0 )); do
        case "${1}" in
            -h|--help)
                help
                exit 0
                ;;
            -f|--fancy)
                FANCY='true'
                ;;
            -l|--log)
                if [[ -z "${2}" ]]; then
                    printf "%s requires an argument: FILE\n" "${1}"
                    help
                    exit 1
                fi
                LOG="${2}"
                shift
                ;;
            -*)
            printf "Unknown flag: %s\n" "${1}"
            help
            exit 1
                ;;
            *)
                # positional args
                printf "Unknown positional argument: %s\n" "${1}"
                help
                exit 1
                ;;
        esac
        shift
    done
}

# wait until next game tick
do_tick() {
    # we use read here because
    # a) it's builtin (sleep is not unless you have it as loadable plugin)
    # b) it allows fractional timeout
    # c) it slurps up input with -s to not mess with screen
    if (( SCORE >= 25 )); then
        read -r -s -t 0.15
    elif (( SCORE >= 20 )); then
        read -r -s -t 0.18
    elif (( SCORE >= 15 )); then
        read -r -s -t 0.21
    elif (( SCORE >= 10 )); then
        read -r -s -t 0.24
    elif (( SCORE >= 5 )); then
        read -r -s -t 0.27
    else
        read -r -s -t 0.3
    fi
}

# input handler
# this reads everything from STDIN and updates
# NEXT_DIRECTION and QUIT
function handle_input() {
    while true; do
        local key

        # get 1 character, regular ascii
        read -r -s -n 1 -t 0.01 key

        # timeout - leave unchanged
        if (( ${?} > 128 )); then
            return 0
        fi

        # if escaped read 2 more chars, arrow keys
        if [[ "${key}" == $'\u1b' ]]; then
            # if timeout is hit here key will just be treated as invalid
            # - which it probably is with just the escape char
            read -r -s -n 2 -t 0.01 key
        fi

        case "${key}" in
            'q')
                QUIT='true'
                ;;
            '[A')
                NEXT_DIRECTION='UP'
                ;;
            '[B')
                NEXT_DIRECTION='DOWN'
                ;;
            '[D')
                NEXT_DIRECTION='LEFT'
                ;;
            '[C')
                NEXT_DIRECTION='RIGHT'
                ;;
        esac
    done
}

# initialise a scene
# should be called on startup and SIGWINCH
function init_scene() {
    # initialise LINES/COLUMNS by calling "external" command
    (:)

    [[ -z "${COLUMNS}" ]] && die 'COLUMNS is unset'
    [[ -z "${LINES}" ]] && die 'LINES is unset'

    log 'Window size update: LINES: %d COLUMNS: %d' \
        "${LINES}" "${COLUMNS}"

    # initially set SLINES/SCOLUMNS
    : "${SLINES:="${LINES}"}"
    : "${SCOLUMNS:="${COLUMNS}"}"

    # hide cursor
    printf '\e[?25l'

    # allocate entire screen worth of lines
    # last line does not need \n
    local line
    for (( line = 0; line < SLINES - 1; line++ )); do
        printf '\n'
    done
}

# destroy a scene
# should be called on exit
# shellcheck disable=SC2317 # this is reachable via trap
function destroy_scene() {
    # deallocate screen
    local line
    for (( line = 0; line < SLINES; line++ )); do
        printf '\e[2K\e[1F'
    done

    # show cursor
    printf '\e[?25h'
}

# draws the scene as defined in ZBUF
# out-of-bounds cells are dropped
# undefined cells are empty
# ZBUF will be cleared after display
function draw_scene() {
    log 'Drawing buffer with dimensions: %dx%d' \
        "${LINES}" "${COLUMNS}"

    # draw buffer
    for (( line = 0; line < LINES; line++ )); do
        printf '\e[%d;%dH\e[0K' "$(( line + 1 ))" 1
        for (( column = 0; column < COLUMNS; column++ )); do
            local cell="${ZBUF["${line}:${column}"]}"
            if [[ -n "${cell}" ]]; then
                printf '%b' "${cell}"
            else
                printf ' '
            fi
        done
    done

    # clear ZBUF
    unset ZBUF
    declare -gA ZBUF

    # update SLINES/SCOLUMNS
    SLINES="${LINES}"
    SCOLUMNS="${COLUMNS}"
}

# regular in-game scene update
function update_scene() {
    local line column
    local element _

    # add scoreboard to bottom right corner
    local score="SCORE: ${SCORE}"
    local i
    for (( i = 0; i < ${#score}; i++)); do
        (( line=(SLINES - 1) ))
        (( column=(SCOLUMNS - 2 - ${#score} + i) ))
        if "${FANCY}"; then
            ZBUF["${line}:${column}"]="\e[36;1m${score:${i}:1}\e[0m"
        else
            ZBUF["${line}:${column}"]="${score:${i}:1}"
        fi
    done

    # add snake
    for element in "${SNAKE[@]}"; do
        IFS=: read -r line column <<<"${element}"
        if "${FANCY}"; then
            ZBUF["${line}:${column}"]="\e[32;1m#\e[0m"
        else
            ZBUF["${line}:${column}"]='#'
        fi
    done

    # add apple
    if [[ -n "${APPLE}" ]]; then
        IFS=: read -r line column _ <<<"${APPLE}"
        if "${FANCY}"; then
            ZBUF["${line}:${column}"]="\e[31;5m@\e[0m"
        else
            ZBUF["${line}:${column}"]='@'
        fi
    fi

    draw_scene
}

# write end screen to ZBUF
# reading screen data from stdin
function end_screen() {
    # line/column where screen starts to draw
    local offset_line="${1:-0}"
    local offset_column="${2:-0}"

    local line column
    local line_txt char

    line="${offset_line}"
    while IFS=$'\0' read -r line_txt; do
        local char
        column="${offset_column}"
        while IFS=$'\0' read -r -n 1 char; do
            if [[ -z "${char}" ]]; then
                break
            fi
            ZBUF["${line}:${column}"]="${char}"
            (( column++ ))
        done <<<"${line_txt}"
        (( line++ ))
    done
}

# end game handler
function end_game() {
    local line column

    # end screen
    # size required to display full end screen
    local height=8
    local width=50

    # if you have the space you get the full experience
    if (( SLINES > height )) && (( SCOLUMNS > width )); then
        log "Displaying full end screen"
        end_screen \
        $(( (SLINES - height) / 2 )) \
        $(( (SCOLUMNS - width) / 2 )) \
        <<EOF
  ___   __   _  _  ____     __   _  _  ____  ____ 
 / __) / _\\ ( \\/ )(  __)   /  \\ / )( \\(  __)(  _ \\
( (_ \\/    \\/ \\/ \\ ) _)   (  O )\\ \\/ / ) _)  )   /
 \\___/\\_/\\_/\\_)(_/(____)   \\__/  \\__/ (____)(__\\_)

SCORE: ${SCORE}

PRESS ANY KEY TO QUIT
EOF
    # else a small simple one that hopefully fits
    # (if it doesn't what are you doing in such a small terminal?)
    else
        log "Displaying minimal end screen"
        end_screen \
        <<EOF
GAME OVER
SCORE: ${SCORE}
PRESS ANY KEY TO QUIT
EOF
    fi

    draw_scene

    # any key to exit
    read -r -n 1
    exit 0
}

# SNAKE update event
function update_snake() {
    # changing 180Â° is not allowed, keep SNAKE_DIRECTION in that case
    case "${SNAKE_DIRECTION}->${NEXT_DIRECTION}" in
        'LEFT->RIGHT'|'RIGHT->LEFT'|'UP->DOWN'|'DOWN->UP')
            NEXT_DIRECTION="${SNAKE_DIRECTION}"
            ;;
    esac

    local line column

    # calculate next head position
    IFS=: read -r line column <<<"${SNAKE[0]}"
    
    case "${NEXT_DIRECTION}" in
        LEFT) (( column-- )) ;;
        RIGHT) (( column++ )) ;;
        UP) (( line-- )) ;;
        DOWN) (( line++ )) ;;
    esac

    # check if head hits a wall
    if (( line < 0 )); then
        end_game
    elif (( line >= SLINES )); then
        end_game
    elif (( column < 0 )); then
        end_game
    elif (( column >= SCOLUMNS )); then
        end_game
    fi

    # check if head hits body
    local element
    for element in "${SNAKE[@]}"; do
        if [[ "${element}" == "${line}:${column}" ]]; then
            end_game 
        fi
    done

    # check if we got an apple
    local apple='false'
    if [[ -n "${APPLE}" ]]; then
        local apple_line apple_column _
        IFS=: read -r apple_line apple_column _ <<<"${APPLE}"
        if (( line == apple_line )) && (( column == apple_column )); then       
            log "Apple collected"
            apple='true'
            APPLE=''
            (( SCORE++ ))
        fi
    fi

    # commit update
    SNAKE_DIRECTION="${NEXT_DIRECTION}"
    SNAKE=( "${line}:${column}" "${SNAKE[@]}" )

    # remove tail element if we didn't get an apple
    if ! "${apple}"; then
        unset "SNAKE[$(( ${#SNAKE[*]} - 1 ))]"
    fi
}

# spawn and despawn apples
function update_apple() {
    local line column ttl

    # spawn new apple
    if [[ -z "${APPLE}" ]]; then
        # we need to make sure apple doesn't spawn inside the snake
        # it's not fatal if it does - just makes it impossible to collect
        # until snake moves away
        local cells cells_free cell_apple
        (( cells=(SLINES * SCOLUMNS) ))
        (( cells_free=(cells - ${#SNAKE[*]}) ))
        (( cell_apple=(RANDOM % cells_free) ))

        log 'Spawning new apple'
        log 'Total cells: %d' "${cells}"
        log 'Free cells: %d' "${cells_free}"
        log 'Apple cell: %d' "${cell_apple}"

        for (( line=0; line < SLINES; line++ )); do
            for (( column=0; column < SCOLUMNS; column++ )); do
                # snake already occupies cell
                if [[ " ${SNAKE[*]} " == *" ${line}:${column} "* ]]; then
                    continue
                fi

                if (( cell_apple == 0 )); then
                    break 2
                fi

                (( cell_apple-- ))
            done
        done

        (( line == SLINES )) && die "line too big"
        (( column == SCOLUMNS )) && die "column too big"

        # ttl is in the range (SLINES+SCOLUMNS)/2 to (SLINES+SCOLUMNS)
        # this should be a reasonable heuristic and allow reaching
        # apples on the other side of the field
        ttl="$(( RANDOM % (SLINES + SCOLUMNS) / 2 + (SLINES + SCOLUMNS) / 2 ))"
        APPLE="${line}:${column}:${ttl}"
        return 0
    fi

    # decrement ttl of existing apple
    IFS=: read -r line column ttl <<<"${APPLE}"
    (( ttl-- ))
    APPLE="${line}:${column}:${ttl}"

    # despawn apple if out-of-bounds
    if (( line >= SLINES )); then
        log 'Despawning out-of-bounds apple'
        APPLE=''
    elif (( column >= SCOLUMNS )); then
        log 'Despawning out-of-bounds apple'
        APPLE=''
    fi

    # despawn apple if ttl reaches 0
    if (( ttl <= 0 )); then
        log "Apple despawned"
        APPLE=''
    fi
}

function main() {
    parse_args "${@}"

    # required shell options
    shopt -s checkwinsize

    # setup scene handlers and init
    trap init_scene WINCH
    trap destroy_scene EXIT
    init_scene

    while ! "${QUIT}"; do
        do_tick
        handle_input
        update_snake
        update_apple
        update_scene
    done

    end_game
}

main "${@}"
